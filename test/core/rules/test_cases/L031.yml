rule: L031

test_1:
  # L031 Allow self-joins
  pass_str: |
    select
      x.a,
      x_2.b
    from x
    left join x as x_2 on x.foreign_key = x.foreign_key

test_2:
  fail_str: |
    SELECT
      u.id,
      c.first_name,
      c.last_name,
      COUNT(o.user_id)
    FROM users as u
    JOIN customers as c on u.id = c.user_id
    JOIN orders as o on u.id = o.user_id;

  fix_str: |
    SELECT
      users.id,
      customers.first_name,
      customers.last_name,
      COUNT(orders.user_id)
    FROM users
    JOIN customers on users.id = customers.user_id
    JOIN orders on users.id = orders.user_id;

test_3:
  # L031 order by
  fail_str: |
    SELECT
      u.id,
      c.first_name,
      c.last_name,
      COUNT(o.user_id)
    FROM users as u
    JOIN customers as c on u.id = c.user_id
    JOIN orders as o on u.id = o.user_id
    order by o.user_id desc

  fix_str: |
    SELECT
      users.id,
      customers.first_name,
      customers.last_name,
      COUNT(orders.user_id)
    FROM users
    JOIN customers on users.id = customers.user_id
    JOIN orders on users.id = orders.user_id
    order by orders.user_id desc

test_4:
  # L031 order by identifier which is the same raw as an alias but refers to a column
  fail_str: |
    SELECT
      u.id,
      c.first_name,
      c.last_name,
      COUNT(o.user_id)
    FROM users as u
    JOIN customers as c on u.id = c.user_id
    JOIN orders as o on u.id = o.user_id
    order by o desc

  fix_str: |
    SELECT
      users.id,
      customers.first_name,
      customers.last_name,
      COUNT(orders.user_id)
    FROM users
    JOIN customers on users.id = customers.user_id
    JOIN orders on users.id = orders.user_id
    order by o desc

alias_single_char_identifiers:
  pass_str: "select b from tbl as a"
  pass_str: "select b from tbl"

alias_with_wildcard_identifier:
  fail_str: "select * from tbl as a"
  fix_str: "select * from tbl"

select_from_values:
  pass_str: |
    select *
    from values(1, 2, 3)

select_from_table_generator:
  pass_str: |
    select *
    from table(
        generator(
            rowcount=>10000
        )
    )

  configs:
    core:
      dialect: snowflake

issue_635:
  pass_str: |
    select
        id::varchar as id,
        obj:userid::varchar as user_id,
        redemptions.value:awardedreceiptid::varchar as awarded_receipt_id
    from
        a,
        lateral flatten(input => a.obj:redemptions) redemptions


  configs:
    core:
      dialect: snowflake

# This query was causing a runtime error in the rule.
issue_239:
  pass_str: |
    WITH
      confusion_matrix AS (
      SELECT
        expected_label,
        commerce,
        digital,
        traditional_services
      FROM
        ML.CONFUSION_MATRIX(MODEL model3,
          (
          SELECT
            *
          FROM
            table1
          WHERE
            training = 0 )))

    SELECT
      *,
      commerce pct_commerce
    FROM
      confusion_matrix
  configs:
    core:
      dialect: bigquery
